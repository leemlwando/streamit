"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const events_1 = require("events");
const lodash_1 = require("../utils/lodash");
const Redis = require('../redis');
const debug = require('../utils/debug')('ioredis:cluster:connectionPool');
class ConnectionPool extends events_1.EventEmitter {
    constructor(redisOptions) {
        super();
        this.redisOptions = redisOptions;
        // master + slave = all
        this.nodes = {
            all: {},
            master: {},
            slave: {}
        };
        this.specifiedOptions = {};
    }
    /**
     * Find or create a connection to the node
     *
     * @param {IRedisOptions} node
     * @param {boolean} [readOnly=false]
     * @returns {*}
     * @memberof ConnectionPool
     */
    findOrCreate(node, readOnly = false) {
        setKey(node);
        readOnly = Boolean(readOnly);
        if (this.specifiedOptions[node.key]) {
            Object.assign(node, this.specifiedOptions[node.key]);
        }
        else {
            this.specifiedOptions[node.key] = node;
        }
        let redis;
        if (this.nodes.all[node.key]) {
            redis = this.nodes.all[node.key];
            if (redis.options.readOnly !== readOnly) {
                redis.options.readOnly = readOnly;
                debug('Change role of %s to %s', node.key, readOnly ? 'slave' : 'master');
                redis[readOnly ? 'readonly' : 'readwrite']().catch(lodash_1.noop);
                if (readOnly) {
                    delete this.nodes.master[node.key];
                    this.nodes.slave[node.key] = redis;
                }
                else {
                    delete this.nodes.slave[node.key];
                    this.nodes.master[node.key] = redis;
                }
            }
        }
        else {
            debug('Connecting to %s as %s', node.key, readOnly ? 'slave' : 'master');
            redis = new Redis(lodash_1.defaults({
                // Never try to reconnect when a node is lose,
                // instead, waiting for a `MOVED` error and
                // fetch the slots again.
                retryStrategy: null,
                // Offline queue should be enabled so that
                // we don't need to wait for the `ready` event
                // before sending commands to the node.
                enableOfflineQueue: true,
                readOnly: readOnly
            }, node, this.redisOptions, { lazyConnect: true }));
            this.nodes.all[node.key] = redis;
            this.nodes[readOnly ? 'slave' : 'master'][node.key] = redis;
            redis.once('end', () => {
                delete this.nodes.all[node.key];
                delete this.nodes.master[node.key];
                delete this.nodes.slave[node.key];
                this.emit('-node', redis);
                if (!Object.keys(this.nodes.all).length) {
                    this.emit('drain');
                }
            });
            this.emit('+node', redis);
            redis.on('error', function (error) {
                this.emit('nodeError', error);
            });
        }
        return redis;
    }
    /**
     * Reset the pool with a set of nodes.
     * The old node will be removed.
     *
     * @param {(Array<string | number | object>)} nodes
     * @memberof ConnectionPool
     */
    reset(nodes) {
        const newNodes = {};
        nodes.forEach((node) => {
            const options = {};
            if (typeof node === 'object') {
                lodash_1.defaults(options, node);
            }
            else if (typeof node === 'string') {
                lodash_1.defaults(options, utils_1.parseURL(node));
            }
            else if (typeof node === 'number') {
                options.port = node;
            }
            else {
                throw new Error('Invalid argument ' + node);
            }
            if (typeof options.port === 'string') {
                options.port = parseInt(options.port, 10);
            }
            delete options.db;
            setKey(options);
            newNodes[options.key] = options;
        }, this);
        Object.keys(this.nodes.all).forEach((key) => {
            if (!newNodes[key]) {
                debug('Disconnect %s because the node does not hold any slot', key);
                this.nodes.all[key].disconnect();
            }
        });
        Object.keys(newNodes).forEach((key) => {
            const node = newNodes[key];
            this.findOrCreate(node, node.readOnly);
        });
    }
}
exports.default = ConnectionPool;
/**
 * Set key property
 *
 * @private
 */
function setKey(node) {
    node = node || {};
    node.port = node.port || 6379;
    node.host = node.host || '127.0.0.1';
    node.key = node.key || node.host + ':' + node.port;
    return node;
}
